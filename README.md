# OOP

## Why OOP?

1. Easier to translate and model real world domain knowledge
2. Build reusable code (DRY) that enforces it's own data
3. Decouple code into logical units
4. Scalability
5. A new way of thinking through problems and software

## Why Not?

1. Not suitable for all programming languages and use cases
2. More complex codebase
3. Overhead / Boilerplate
4. Easy to make fake OOP
5. It's a black box

## SOLID Principles

1. Single Responsibility Principle
2. Open-Closed Principle
3. Liskov Substitution Principle
4. Interface Segregation Principle
5. Dependency Inversion Principle

